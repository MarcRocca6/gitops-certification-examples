# ArgoCD Notes & Examples

## Pruning, Syncing & Healing

###### Syncing 
An application is synced when there are no differences in the Git maniftes and the live state in the cluster. Argo CD has the ability to automatically sync an application when it detects differences between the desired manifests in Git, and the live state in the cluster. A benefit of automatic sync is that CI/CD pipelines no longer need direct access to the Argo CD API server to perform the deployment. Instead, the pipeline makes a commit and push to the Git repository with the changes to the manifests in the tracking Git repo. To configure automated sync run:

`argocd app set <APPNAME> --sync-policy automated`

###### Healing 
Automatic Sync does not cover the case when an application is out of sync due to an unexpected change in the target cluster. With Self-Healing enabled, Argo CD automatically forces the desired state from Git into the cluster every time when state deviation is detected. By default, changes that are made to the live cluster will not trigger automated sync. ArgoCD will force the state defined in Git into the cluster when a deviation in the cluster is detected. To enable automatic sync when the live cluster's state deviates from the state defined in Git, run:

`argocd app set <APPNAME> --self-heal`

###### Pruning
By default (and as a safety mechanism), automated sync will not delete resources when Argo CD detects the resource is no longer defined in Git. To prune the resources, a manual sync can always be performed (with pruning checked). Pruning can also be enabled to happen automatically as part of the automated sync by running:

`argocd app set <APPNAME> --allow-empty`


#### Deploy Argo CD to Kubernetes
Use the terminal to deploy Argo CD:

`kubectl create namespace argocd`
`kubectl apply -n argocd -f https://raw.githubusercontent.com/codefresh-contrib/gitops-certification-examples/main/argocd-noauth/install.yaml`

This will create a new namespace, argocd, where Argo CD services and application resources will live.

To view the deployment enter

`kubectl get pods -n argocd`

Note that this is simple installation method without any authentication. In a real setting you would probably setup SSO with your ArgoCD instance.

#### Expose the Argo CD UI
Feel free to look at the file service.yml in the Editor tab. It is a standard NodePort service resource.

Use the terminal to create it in the cluster:

`kubectl apply -f service.yml`

After the service is created, check the "Argo CD UI" tab to access the Argo CD Web interface.

## Log in the Argo CD UI
Argo CD initially has an admin user with an autogenerated password. You can get the admin password from the default Configmap

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d > admin-pass.txt`

Just to make things simple we have disabled authentication in the ArgoCD UI.
Simply use the "ArgoCD UI" tab to look at the interface Everything is empty right now.

## Argo CD CLI

###### Step 1
To install the CLI

`curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/v2.1.5/argocd-linux-amd64`
`chmod +x /usr/local/bin/argocd`
###### Step 2
Test that the CLI works by typing

`argocd help`


#### Login with the CLI
###### Step 1
To authenticate

`argocd login localhost:30443 --insecure`

We use the insecure option because Argo CD has a self-signed certificate. In a production installation you would have a real certificate and this option should not be used.

Log in as admin and use the password stored in admin-pass.txt. You can see the value from the editor tab.

Notice that for security reasons the password you paste is not shown in the terminal (not even with asterisks). Just paste the password value and press Enter.

###### Step 2
Run some example commands

`argocd version`
`argocd app list`

##  Creating an Argo CD application with the argocd CLI

`argocd app create {APP NAME} \
--project {PROJECT} \
--repo {GIT REPO} \--path {APP FOLDER} \
--dest-namespace {NAMESPACE} \
--dest-server {SERVER URL}`

* {APP NAME} is the name you want to give the application
* {PROJECT} is the name of the project created or "default"
* {GIT REPO} is the url of the git repository where the gitops config is located
* {APP FOLDER} is the path to the configuration for the application in the gitops repo
* {DEST NAMESPACE} is the target namespace in the cluster where the application will be deployed
* {SERVER URL} is the url of the cluster where the application will be deployed. Use https://kubernetes.default.svc to reference the same cluster where Argo CD has been deployed

Once this completes, you can see the status and configuration of the application.

`argocd app list`

For a more detailed view of the application configuration, run:

`argocd app get {APP NAME}`

####  Synchronizing an Argo CD application with the argocd CLI

Initially, the application is in OutOfSync state since the application has yet to be deployed, and no Kubernetes resources have been created.

Since the application is in OutOfSync status once created because it hasn’t been deployed yet, we will then sync the application with a sync command.

`argocd app sync {APP NAME}`

This synchronizes the application. To confirm it’s running, you can execute a 

`kubectl command.`
`kubectl -n {NAMESPACE} get all`

The application will have a status “Running” if synchronized successfully.

##  Create App Demo in Argo CD CLI

Apart from the UI, ArgoCD also has a CLI. We have installed already the cli for you and authenticated against the instance.

Try the following commands

`argocd app list`
`argocd app get demo`
`argocd app history demo`

Let's delete the application and deploy it again but from the CLI this time.
First delete the app

`argocd app delete demo`

Confirm the deletion by answering yes in the terminal. The application will disappear from the Argo CD dashboard after some minutes.

Now deploy it again.

`argocd app create demo2 \
--project default \
--repo https://github.com/codefresh-contrib/gitops-certification-examples \
--path "./simple-app" \
--dest-namespace default \
--dest-server https://kubernetes.default.svc`

The application will appear in the ArgoCD dashboard.
Now sync it with

`argocd app sync demo2`

##  Detecting cluster changes

Let's bring the cluster back to the same state as Git. Click the Sync button in the UI to make the application synced with the new version.

You can also execute the following from the CLI:

`argocd app sync demo`
`argocd app wait demo`

Detecting changes in Git and applying is a well known scenario. The big strength of GitOps, is that Argo CD works in the opposite direction as well. If you make any change in the cluster then Argo CD will detect it and again tell you that something is different between Git and your cluster.

Let's say that somebody changes manually the replicas of the deployment without creating an official Pull Request (a bad practice in general).

Execute the following

`kubectl scale --replicas=3 deployment simple-deployment`

Normally Argo CD checks the state between Git and the cluster every 3 minutes on its own. Just to speed things up you should click manually on the application in the Argo CD dashboard and press the "Refresh" button. The click the "App diff" button and enable the "Compact Diff" checkbox.

`git-change`

Argo CD again detects the change between the two states. This capability is very powerful and you can easily detect configuration drift between your environments.

##  Application Health

Apart from the synced/out-of-sync status, Argo CD also keeps track of the service health for each deployed application. The health status is shown in the UI and can also be retrieved by the CLI.

The possible values are:

* “Healthy” -> Resource is 100% healthy
* “Progressing” -> Resource is not healthy but still has a chance to reach healthy state
* “Suspended” -> Resource is suspended or paused. The typical example is a cron job
* “Missing” -> Resource is not present in the cluster
* “Degraded” -> Resource status indicates failure or resource could not reach healthy state in time
* “Unknown” -> Health assessment failed and actual health status is unknown

##  Sync Strategies

In the previous sections we created an Argo CD application and chose a manual sync strategy for demonstration purposes. However, Argo CD has many more options when it comes to syncing.

There are 3 parameters that you can change when defining the sync strategy:
Manual or automatic sync.
Auto-pruning of resources - this is only applicable for automatic sync.
Self-Heal of cluster - this is only applicable for automatic sync.

Manual or automatic sync defines what Argo CD does when it finds a new version of your application in Git. If set to automatic, Argo CD will apply the changes then update/create new resources in the cluster. If set to manual, Argo CD will detect the change but will not change anything in the cluster.

Auto-pruning defines what Argo CD does when you remove/delete files from Git. If it is enabled, Argo CD will also remove the respective resources in the cluster as well. If disabled, Argo CD will never delete anything from the cluster.

Self-heal defines what Argo CD does when you make changes directly to the cluster (via kubectl or any other way). Note that doing manual changes in the cluster is not recommended if you want to follow GitOps principles (as all changes should pass from Git). If enabled, then Argo CD will discard the extra changes and bring the cluster back to the state described in Git.

This means that you have several combinations of all the settings as shown in the following table:
| Policy        | A       |  B       | C        |  D       | E       |
|---------------|---------|----------|----------|----------|---------|
| Sync Strategy |  Manual | Auto     | Auto     | Auto     | Auto    |
| Auto-prune    | N/A     | Disabled | Enabled  | Disabled | Enabled |
| Self-heal     | N/A     | Disabled | Disabled |  Enabled | Enabled |

Policy A (nothing is done by Argo CD) is probably how you should start adopting Argo CD , especially if you want to apply GitOps on an existing project. This is your chance to see how Argo CD works, without actually affecting your deployments.

Policy B (auto-sync) is the first step towards following GitOps with its automation capabilities. As soon as any change happens in Git, your cluster will auto-update. Disabling auto-prune means that you must still delete resources manually, and disabled self-heal means that you can still make manual changes to the cluster (if you want to have a migration period).

Policies C and D are orthogonal and can act as stepping stones to Policy E, which is the one you should look up to. 
Under that policy, everything is automated both ways. Changes in Git are also reflected automatically to the cluster (including removals of resources), and manual changes in the cluster are simply discarded.

Adopting GitOps in its purest form may require organizational changes or a reexamination of policies and your organization may not be ready at this point. While correcting drift automatically will help organizations get the most out of GitOps, it may take some time to be ready.

## Codefresh GitOps Certification examples

This repository contains examples for the ArgoCD/GitOps
certification workshops.

Take the certification yourself at https://codefresh.io/courses/get-gitops-certified/
